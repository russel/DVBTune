/*
 *  DVBTune — for generating a DVBv5 channels file from a DVBv5 transmitter file.
 *
 *  Copyright © 2019, 2020  Russel Winder
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program. If not, see <http://www.gnu.org/licenses/>.
 */

//! Module realising the two abstractions needed for this application.
//!
//! * `TransmitterFile` – represents the file with all the transmitter channel/transponder
//! data (e.g. /usr/share/dvb/dvb-t/uk-CrystalPalace) and allows for a scan to be undertaken
//! using a frontend of a DVB device.
//! * `ChannelsData` – the result of a scan on a `TransmitterFile` is a file of all the channels
//! represented by a returned `ChannelsData` instance which allows the data to be written
//! to a file on the filestore.

use std::ffi::{CStr,CString};
use std::io::{Write, stderr};
use std::path::Path;
use std::thread::sleep;
use std::time::Duration;

use libc;

use dvbv5_sys;

use dvbv5;

/// An opaque structure for writing to filestore a file of channel data
/// generated by an execution of `TransmitterFile::scan`.
#[derive(Debug)]
pub struct ChannelsData {
    file_ptr: dvbv5::FilePtr,
    frontend_parameters_ptr: dvbv5::FrontendParametersPtr,
}

impl ChannelsData {

    /// Create a `ChannelData` instance given a `FilePtr` instance and a `FrontendParametersPtr` instance.
    fn new(file_ptr: dvbv5::FilePtr, frontend_parameters_ptr: dvbv5::FrontendParametersPtr) -> ChannelsData {
        ChannelsData{file_ptr, frontend_parameters_ptr}
    }

    /// Write the data in this `ChannelData` instance to a file on the filestore.
    pub fn write(&self, output_path: &Path) -> bool {
        if dvbv5::write_file_format(&output_path, &self.file_ptr, self.frontend_parameters_ptr.get_current_sys(), dvbv5::dvb_file_formats::FILE_DVBV5) {
            self.frontend_parameters_ptr.log(dvbv5::log_level::LOG_INFO, &format!("\nWrote virtual channels file to: {}", output_path.display()));
            true
        } else {
            self.frontend_parameters_ptr.log(dvbv5::log_level::LOG_INFO, &format!("\nWrite to {} failed.", output_path.display()));
            false
        }
    }
}

/// A wrapper around a `dvbv5::FilePtr` for processing the file of transmitter data.
/// Sets up the ability to scan using a frontend of a USB DVB device.
#[derive(Debug)]
pub struct TransmitterData {
    ptr: dvbv5::FilePtr,
}

impl TransmitterData {

    /// Open the transmitter file.
    pub fn new(transmitter_file: &Path) -> Result<TransmitterData, ()> {
        match dvbv5::FilePtr::new(transmitter_file, None, None) {
            Ok(ptr) => Ok(TransmitterData{ptr}),
            Err(_) => Err(()),
        }
    }

    /// Write scan status data to stderr. If stderr is a terminal then use the codes to
    /// change colours.
    ///
    /// This is a function a pointer to which is passed to the scan function for printing
    /// out various bits and pieces during the scan.
    extern "C" fn frontend_check(_arguments: *mut std::ffi::c_void, frontend_parameters: *mut dvbv5_sys::dvb_v5_fe_parms) -> i32 {
        unsafe {
            let logger = (*frontend_parameters).logfunc.unwrap();
            let mut status = dvbv5::fe_status::FE_NONE as u32;
            let mut n_status_lines = 0 as u32;
            let mut stream = stderr();
            let  stream_fd = libc::STDERR_FILENO;
            // Try 20 times to get a lock. It usually takes three to six attempts.
            for _ in 0..20 {
                if (*frontend_parameters).abort != 0 { return 0; }
                if dvbv5_sys::dvb_fe_get_stats(frontend_parameters) != 0 {
                    logger(dvbv5::log_level::LOG_INFO as i32, CString::new("dvb_fe_get_stats failed.").unwrap().as_ptr());
                } else {
                    if dvbv5_sys::dvb_fe_retrieve_stats(frontend_parameters, dvbv5::dtv_retrievable_properties::DTV_STATUS as u32, &mut status) != 0 {
                        logger(dvbv5::log_level::LOG_INFO as i32, CString::new("dvb_fe_retrieve_stats of DVT_STATUS failed.").unwrap().as_ptr());
                        status = dvbv5::fe_status::FE_NONE as u32;
                    } else {
                        if libc::isatty(stream_fd) != 0 {
                            if n_status_lines != 0 {
                                // If there are status lines then return to the beginning of the line go back up a line and clear it.
                                write!(stream, "\r\x1b[{}A\x1b[J", n_status_lines).unwrap();
                                n_status_lines = 0;
                            }
                            if status & dvbv5::fe_status::FE_HAS_LOCK as u32 != 0 {
                                // Set colour to bold green
                                write!(stream, "\x1b[1;32m").unwrap();
                            } else {
                                // Set colour to yellow
                                write!(stream, "\x1b[33m").unwrap();
                            }
                        }
                        let buffer_size = 1024;
                        let buffer = ['a'; 1024]; // Can't use the "variable" buffer_size here :-(.
                        let mut current_position = buffer.as_ptr() as *mut i8;
                        let mut usable_length = buffer_size;
                        //
                        // TODO dvb_fe_snprintf_stat returns the number of characters "printed", and a negative value on error.
                        //  Should the code be testing that there are no errors?
                        //
                        let mut show = 0;
                        dvbv5_sys::dvb_fe_snprintf_stat(frontend_parameters, dvbv5::dtv_retrievable_properties::DTV_STATUS as u32, 0 as *mut i8, 0, &mut current_position, &mut usable_length, &mut show);
                        for i in 0..dvbv5_sys::MAX_DTV_STATS as i32 {
                            show = 1;
                            dvbv5_sys::dvb_fe_snprintf_stat(frontend_parameters, dvbv5::dtv_retrievable_properties::DTV_QUALITY as u32, CString::new("Quality").unwrap().as_ptr() as *mut i8, i, &mut current_position, &mut usable_length, &mut show);
                            dvbv5_sys::dvb_fe_snprintf_stat(frontend_parameters, dvbv5::dtv_retrievable_properties::DTV_STAT_SIGNAL_STRENGTH as u32, CString::new("Signal").unwrap().as_ptr() as *mut i8, i, &mut current_position, &mut usable_length, &mut show);
                            dvbv5_sys::dvb_fe_snprintf_stat(frontend_parameters, dvbv5::dtv_retrievable_properties::DTV_STAT_CNR as u32, CString::new("C/N").unwrap().as_ptr() as *mut i8, i, &mut current_position, &mut usable_length, &mut show);
                            dvbv5_sys::dvb_fe_snprintf_stat(frontend_parameters, dvbv5::dtv_retrievable_properties::DTV_STAT_ERROR_BLOCK_COUNT as u32, CString::new("UCB").unwrap().as_ptr() as *mut i8, i, &mut current_position, &mut usable_length, &mut show);
                            dvbv5_sys::dvb_fe_snprintf_stat(frontend_parameters, dvbv5::dtv_retrievable_properties::DTV_BER as u32, CString::new("postBER").unwrap().as_ptr() as *mut i8, i, &mut current_position, &mut usable_length, &mut show);
                            dvbv5_sys::dvb_fe_snprintf_stat(frontend_parameters, dvbv5::dtv_retrievable_properties::DTV_PRE_BER as u32, CString::new("preBER").unwrap().as_ptr() as *mut i8, i, &mut current_position, &mut usable_length, &mut show);
                            dvbv5_sys::dvb_fe_snprintf_stat(frontend_parameters, dvbv5::dtv_retrievable_properties::DTV_PER as u32, CString::new("PER").unwrap().as_ptr() as *mut i8, i, &mut current_position, &mut usable_length, &mut show);
                            if current_position != buffer.as_ptr() as *mut i8 {
                                let line = CStr::from_ptr(buffer.as_ptr() as *mut i8).to_str().unwrap();
                                if n_status_lines != 0 {
                                    write!(stream, "\t{}\n", line).unwrap();
                                } else {
                                    write!(stream, "{}\n", line).unwrap();
                                }
                                n_status_lines += 1;
                                current_position = buffer.as_ptr() as *mut i8;
                                usable_length = buffer_size;
                            }
                        }
                        stream.flush().unwrap();
                    }
                }
                if status & dvbv5::fe_status::FE_HAS_LOCK as u32 != 0 { break; }
                sleep(Duration::from_millis(100));
            }
            if libc::isatty(stream_fd) != 0 {
                //  Set default foreground colour without bold.
                write!(stream, "\x1b[22;39m").unwrap();
                stream.flush().unwrap();
            }
            if status & dvbv5::fe_status::FE_HAS_LOCK as u32 != 0 { 0 } else { -1 }
        }
    }

    /// Perform a scan on the channel/transponders listed in this transmitter file.
    ///
    /// * `frontend_id` – the frontend to use for the scan.
    /// * `other_nit` – an `Option` `bool`; use alternate table IDs for NIT and other
    /// tables. Default `false`.
    /// * `timeout_multiplier` – an `Option` unsigned integer; increases the timeout for each
    /// table reception. Default 1.
    /// * `get_detected` –an `Option` `bool`; if `true`, uses the frontend parameters obtained
    /// from the device driver (such as modulation, FEC, etc). Default `true`.
    /// * `get_nit` – an `Option` `bool`; if true, uses the parameters obtained from the
    /// MPEG-TS NIT table to add newly detected transponders. Default `true`.
    /// * `dont_add_new_frequencies` – an `Option` `bool` determining whether newly found
    /// frequencies should be scanned for channels. Default `false`.
    /// * `verbose` – an `Option` `u32` stating the level of verbosity. Default 0.
    /// * `use_legacy_call` – an `Option` `bool` specifying whether DVBv3 format should be used
    /// rather than DVBv5 format. Default `false`.
    pub fn scan(
        &self,
        frontend_id: &dvbv5::FrontendId,
        other_nit: Option<bool>,
        timeout_multiplier: Option<u32>,
        get_detected: Option<bool>,
        get_nit: Option<bool>,
        dont_add_new_frequencies: Option<bool>,
        verbose: Option<u32>,
        use_legacy_call: Option<bool>,
    ) -> Result<ChannelsData, ()> {
        let get_detected = get_detected.unwrap_or(true);
        let get_nit = get_nit.unwrap_or(true);
        let dont_add_new_frequencies = dont_add_new_frequencies.unwrap_or(false);
        match dvbv5::FrontendParametersPtr::new(&frontend_id,verbose, use_legacy_call) {
            Ok(frontend_parameters) => {
                let dmx_fd = dvbv5::DmxFd::new(&frontend_id).unwrap();
                // TODO Is there a way of using FilePtr instead of *mut dvbv5_sys::dvb_file?
                //   Possibly not because of the RAII of FilePtr instances.
                let mut channels_file = 0 as *mut dvbv5_sys::dvb_file;
                for (index, entry) in self.ptr.iter().enumerate() {
                    match dvbv5::retrieve_entry_prop(&entry, dvbv5::dtv_retrievable_properties::DTV_FREQUENCY) {
                        Ok(frequency) => {
                            frontend_parameters.log(dvbv5::log_level::LOG_INFO, &format!("\nScanning frequency #{} {}", index + 1, frequency));
                            if let Ok(channel) = entry.get_channel() {
                                frontend_parameters.log(dvbv5::log_level::LOG_INFO, &format!("Channel name: {}", channel));
                            }
                            if let Ok(vchannel) = entry.get_vchannel() {
                                frontend_parameters.log(dvbv5::log_level::LOG_INFO, &format!("Channel number: {}", vchannel));
                            }
                            if let Ok(location) = entry.get_location() {
                                frontend_parameters.log(dvbv5::log_level::LOG_INFO, &format!("Channel location: {}", location));
                            }
                            match dvbv5::ScanHandlerPtr::new(&frontend_parameters, &entry, &dmx_fd, Some(Self::frontend_check), other_nit, timeout_multiplier) {
                                Ok(scan_handler) => {
                                    if frontend_parameters.get_abort() { break; }
                                    match dvbv5::store_channel(channels_file, &frontend_parameters, &scan_handler, get_detected, get_nit) {
                                        Ok(c_f) => channels_file = c_f,
                                        Err(_) => frontend_parameters.log(dvbv5::log_level::LOG_INFO, "Failed to store some channels."),
                                    }
                                    if !dont_add_new_frequencies {
                                        dvbv5::add_scaned_transponders(&frontend_parameters, &scan_handler, &self.ptr, &entry);
                                    }
                                },
                                Err(_) => frontend_parameters.log(dvbv5::log_level::LOG_INFO, "Failed to initialise scan handler."),
                            }
                        },
                        Err(_) =>{},
                    }
                }
                Ok(ChannelsData::new(
                    dvbv5::FilePtr::new_from_dvb_file_ptr(channels_file).unwrap(),
                    frontend_parameters))
            },
            Err(e) => Err(e),
        }
    }
}

#[cfg(test)]
mod tests {

    use std::path::Path;

    use super::*;

    #[test]
    fn fail_to_scan_with_silly_frontend() {
        // This is the Debian location. Fedora has it somewhere else.
        let path = Path::new("/usr/share/dvb/dvb-t/uk-CrystalPalace");
        if path.exists() {
            match TransmitterData::new(path) {
                Ok(transmitter_data) => {
                    // NB Assume that this FrontendId doesn't exist at the time of the test.
                    // Does any adapter have this many frontends?
                    if transmitter_data.scan(
                        &dvbv5::FrontendId{adapter_number: 254, frontend_number: 254},
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                        None,
                    ).is_ok() {
                        assert!(false, "Unexpected working scan.");
                    }
                },
                Err(e) => assert!(false, "Could not read transmitter data."),
            }
        } else {
            println!("Path {} did not exist, no test undertaken.", path.display());
        }

    }
}
